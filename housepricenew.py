# -*- coding: utf-8 -*-
"""housepriceNew.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/194eHXGT8_BzxMpwtnFfliUIkTx7IUnBM
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy import stats
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error as mse
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
# %matplotlib inline 
#stored within the notebook
import matplotlib
matplotlib.rcParams['figure.figsize'] = (20, 10)
import warnings
warnings.filterwarnings('ignore')

Data_frame = pd.read_csv("Bengaluru_House_Data.csv", na_values=[' ?'])
Data_frame.head(10)

for i in Data_frame.columns:
    print(Data_frame[i].value_counts())
    print("\n")

for i in Data_frame.columns:
    print(f'{i} \n {Data_frame[i].unique()}')
    print("\n")

Data_frame.shape

Data_frame_copy = Data_frame.copy()
Data_frame.drop(['availability', 'society'], axis=1, inplace=True)

Data_frame.isnull().sum()

# Droping Missing Values 
Data_frame.dropna(subset = ['location', 'size', 'bath'], inplace=True)
Data_frame.shape

Data_frame.info()

#Replacing Missing Values
sns.boxplot(x='balcony', data=Data_frame)
plt.title("Balcony-BoxPlot")
plt.show()
#Replacing the missing data with mean 
Data_frame['balcony'].replace(np.nan, Data_frame['balcony'].mean(), inplace=True)

Data_frame.isnull().sum()

Data_frame['BHK'] = Data_frame['size'].apply(lambda x: int(x.split(' ')[0]))
Data_frame.drop(['size'], axis=1, inplace=True)
Data_frame.head()

print(f"{Data_frame['total_sqft'].value_counts()} \n\n {Data_frame['total_sqft'].unique()}")

def is_float(x):
    try:
        float(x)
    except:
        return False
    return True

~Data_frame['total_sqft'].apply(is_float)
Temp_df = Data_frame[~Data_frame['total_sqft'].apply(is_float)]

def check_abnormal(x):
    if '-' in x:
        return False
    else:
        return True

Temp_df['total_sqft'][Temp_df['total_sqft'].apply(check_abnormal)].value_counts()

len(Temp_df['total_sqft'][Temp_df['total_sqft'].apply(check_abnormal)].unique())

#Creating Function to Convert ranges to a single Value 

def abnormal_change(x):
    if "Sq. Meter" in x:
        num = x.split("S")
        result = float(num[0]) * 10.76
        return result
    if "Perch" in x:
        num = x.split("P")
        result = float(num[0]) * 272.25
        return result
    if "Sq. Yards" in x:
        num = x.split("S")
        result = float(num[0]) * 9.00
        return result
    if "Acres" in x:
        num = x.split("A")
        result = float(num[0]) * 43560.04
        return result
    if "Cents" in x:
        num = x.split("C")
        result = float(num[0]) * 435.56
        return result
    if "Guntha" in x:
        num = x.split("G")
        result = float(num[0]) * 1089.00
        return result
    if "Grounds" in x:
        num = x.split("G")
        result = float(num[0]) * 2400.35
        return result

def convert_range_to_num(x):
    if '-' in x:
        num = x.split('-')
        result1 = (float(num[0]) + float(num[1]))/2
    else:
        bool_val = x.upper().isupper()
        if bool_val == True:
            result1 = abnormal_change(x)
        else:
            result1 = float(x)
    return result1

Data_frame['total_sqft'] = Data_frame['total_sqft'].apply(convert_range_to_num)

Data_frame.isnull().sum()

Data_frame.info()

Data_frame.rename(columns = {'bath':'bathroom'}, inplace=True)
Data_frame.columns

# Adding a Column / Feature which is important for future use [outlier treatment ] + gives a proper insight of a property
Data_frame['price_per_sqft'] = Data_frame['price']*100000 / Data_frame['total_sqft']
Data_frame.head()

count_location = len(Data_frame['location'].unique())
print(count_location)
pd.set_option('display.max_rows', count_location)
Location_data = Data_frame.groupby('location')['location'].agg('count').sort_values(ascending=False)
Location_data.head(200)

filt = Location_data <= 15
len(Location_data[filt])

Location_data_less_than_15 = Location_data[filt]
Location_data_less_than_15.head()

Location_data_less_than_15.tail()

Data_frame['location'] = Data_frame['location'].apply(lambda x: 'Other' if x in Location_data_less_than_15 else x)
print(count_location)
count_location_dimen_red = len(Data_frame['location'].unique())
print(count_location_dimen_red)
Data_frame.head(10)

Data_frame_numeric = Data_frame.select_dtypes(include=np.number)
Data_frame_numeric.head(10)

Data_frame.head(10)

for i in Data_frame_numeric.columns:
    sns.boxplot(x=i, data=Data_frame_numeric)
    plt.title(i)
    plt.show()

Data_frame['total_sqft'].describe()

# total_sqft -> Treating outliers using Flooring and Capping
sns.histplot(x='total_sqft', data=Data_frame)
plt.xlim([0, 6000])
plt.show()

sns.boxplot(x='total_sqft', data=Data_frame)
plt.show()

# Applying Quantile Based Flooring and capping
lower_bound = Data_frame['total_sqft'].quantile(0.10)
upper_bound = Data_frame['total_sqft'].quantile(0.90)
Data_frame['total_sqft'] = np.where(Data_frame['total_sqft'] < lower_bound, lower_bound, Data_frame['total_sqft'])
Data_frame['total_sqft'] = np.where(Data_frame['total_sqft'] > upper_bound, upper_bound, Data_frame['total_sqft'])

# Bathroom - small quanitites of Outliers so Replace them with median 
median = Data_frame['bathroom'].quantile(0.50)
upper_out = Data_frame['bathroom'].quantile(0.95)
Data_frame['bathroom'] = np.where(Data_frame['bathroom'] > upper_out, median, Data_frame['bathroom'])

sns.boxplot(x='bathroom', data=Data_frame)
plt.show()

# Applying Quantile Based Flooring and capping
lower_bound = Data_frame['price'].quantile(0.10)
upper_bound = Data_frame['price'].quantile(0.90)
Data_frame['price'] = np.where(Data_frame['price'] < lower_bound, lower_bound, Data_frame['price'])
Data_frame['price'] = np.where(Data_frame['price'] > upper_bound, upper_bound, Data_frame['price'])

# BHK - small quanitites of Outliers so Replace them with median 
median = Data_frame['BHK'].quantile(0.50)
upper_out = Data_frame['BHK'].quantile(0.98)
Data_frame['BHK'] = np.where(Data_frame['BHK'] > upper_out, median, Data_frame['BHK'])

Data_frame[~(Data_frame['bathroom'] < (Data_frame['BHK'] + 2))].shape

Data_frame[(Data_frame['bathroom'] < (Data_frame['BHK'] + 2))].shape

Data_frame.shape

Data_frame = Data_frame[(Data_frame['bathroom'] < (Data_frame['BHK'] + 2))]
Data_frame.shape

Data_frame['balcony'] = Data_frame['balcony'].astype('int')

Data_frame.head(10)

# Applying Quantile Based Flooring and capping
lower_bound = Data_frame['price_per_sqft'].quantile(0.10)
upper_bound = Data_frame['price_per_sqft'].quantile(0.90)
Data_frame['price_per_sqft'] = np.where(Data_frame['price_per_sqft'] < lower_bound, lower_bound, Data_frame['price_per_sqft'])
Data_frame['price_per_sqft'] = np.where(Data_frame['price_per_sqft'] > upper_bound, upper_bound, Data_frame['price_per_sqft'])

def remove_bhk_outliers(df):
    exclude_indices = np.array([])
    for location, location_df in df.groupby('location'):
        bhk_stats = {}
        for bhk, bhk_df in location_df.groupby('BHK'):
            bhk_stats[bhk] = {
                'mean': np.mean(bhk_df.price_per_sqft),
                'std': np.std(bhk_df.price_per_sqft),
                'count': bhk_df.shape[0]
            }
        for bhk, bhk_df in location_df.groupby('BHK'):
            stats = bhk_stats.get(bhk-1)
            if stats and stats['count']>5:
                exclude_indices = np.append(exclude_indices, bhk_df[bhk_df.price_per_sqft<(stats['mean'])].index.values)
    return df.drop(exclude_indices,axis=0)
Data_frame = remove_bhk_outliers(Data_frame)
Data_frame.shape

Data_frame.drop(['price_per_sqft'], axis=1, inplace=True)

#Check
Data_frame[Data_frame.total_sqft/Data_frame.BHK<300].head(10)

Data_frame=Data_frame[~(Data_frame.total_sqft/Data_frame.BHK<300)]
Data_frame.shape

num_corr = Data_frame[['total_sqft', 'bathroom', 'balcony', 'BHK', 'park_faci', 'dist_mainroad']].corr()
num_corr

sns.heatmap(num_corr, cmap='RdBu')
plt.title("Heatmap of Correlation between numeric Independent Features")
plt.show()

corr_tot_pr = Data_frame[['total_sqft', 'price']].corr()
corr_tot_pr

pearson_tot_pr = stats.pearsonr(Data_frame['total_sqft'], Data_frame['price'])
pearson_tot_pr

corr_bath_pr = Data_frame[['bathroom', 'price']].corr()
corr_bath_pr

pearson_bath_pr = stats.pearsonr(Data_frame['bathroom'], Data_frame['price'])
pearson_bath_pr

corr_bal_pr = Data_frame[['balcony', 'price']].corr()
corr_bal_pr

pearson_bal_pr = stats.pearsonr(Data_frame['balcony'], Data_frame['price'])
pearson_bal_pr

corr_bhk_pr = Data_frame[['BHK', 'price']].corr()
corr_bhk_pr

pearson_bhk_pr = stats.pearsonr(Data_frame['BHK'], Data_frame['price'])
pearson_bhk_pr

df1 = Data_frame[['area_type', 'price']]
df_g = df1.groupby(['area_type'], as_index=False).mean().sort_values(ascending=False, by='price')
df_g.rename(columns={'price':'avg-price'}, inplace=True)
df_g.set_index('area_type', inplace=True)
df_g

df2 = Data_frame[['location', 'price']]
df_l = df2.groupby(['location'], as_index=False).mean().sort_values(ascending=False, by='price')
df_l.rename(columns={'price':'avg-price'}, inplace=True)
df_l.set_index('location', inplace=True)
df_l.head(10)

df3 = Data_frame[['area_type','location', 'price']]
df_p = df3.groupby(['area_type','location'], as_index=False).mean().sort_values(ascending=False, by='price')
df_p.set_index('area_type', inplace=True)
df_p.rename(columns={'price':'avg-price'}, inplace=True)
df_pivot = pd.pivot_table(df_p, index='area_type', columns='location', values='avg-price')
df_pivot.fillna(0, inplace=True)
df_pivot

one_dum = pd.get_dummies(Data_frame['area_type'])
Data_frame = pd.concat([Data_frame, one_dum], axis=1)
Data_frame.drop(['area_type'], axis=1, inplace=True)

ne_dum = pd.get_dummies(Data_frame['location'])
Data_frame = pd.concat([Data_frame, ne_dum], axis=1)
Data_frame.drop(['location'], axis=1, inplace=True)

Data_frame.shape

X = Data_frame.drop(['price'], axis=1)
X.shape

Y = Data_frame['price']
Y.shape

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.17, random_state=42)
print(f"{X_train.shape} \n {X_test.shape} \n {Y_train.shape} \n {Y_test.shape}")

LinearModel = LinearRegression()
LinearModel.fit(X_train, Y_train)
Y_pred = LinearModel.predict(X_test)
Y_pred

Y_pred_train = LinearModel.predict(X_train)
Y_pred_train

# mse value - Test
MSE = mse(Y_test, Y_pred)
MSE

# mse value - train
MSE_t = mse(Y_train, Y_pred_train)
MSE_t

# R^2 Value - Train
r2_val_t = LinearModel.score(X_train, Y_train)
r2_val_t

# R^2 Value - Test
r2_val = LinearModel.score(X_test, Y_test)
r2_val

from sklearn.metrics import r2_score
r2_score(Y_test, Y_pred)

r2_score(Y_train, Y_pred_train)

LinearModel.intercept_

for i in range(0, 6):
    print(LinearModel.coef_[i])

# Dist Plot
axis = sns.distplot(x=Y_test, hist=False, color='red', label='Actual Data')
sns.distplot(x=Y_pred, hist=False, color='blue', label='Predicted Data', ax=axis)
plt.xlabel('Price')
plt.title('Actual value vs Predicted Value')
plt.legend(loc='best')
plt.show()

# Scatter Plot
sns.set(color_codes=True)
sns.set_style("white")

ax = sns.regplot(Y_test, Y_pred, scatter_kws={'alpha':0.4})
ax.set_xlabel('Original Value - Price', fontsize='large', fontweight='bold')
ax.set_ylabel('Predicted Value - Price', fontsize='large', fontweight='bold')
ax.set_xlim(35, 135)
ax.set_ylim(15, 135)
plt.show

def predict_price(area_type, location, sqft, balcony, bathroom, BHK, park_faci, dist_mainroad):
    area_index = np.where(X.columns==area_type)[0][0]
    loc_index = np.where(X.columns==location)[0][0]
    
    lis = np.zeros(len(X.columns))
    lis[0] = sqft
    lis[1] = bathroom
    lis[2] = balcony
    lis[3] = BHK
    lis[4] = park_faci
    lis[5] = dist_mainroad
    
    if loc_index >=0 and area_index >=0:
        lis[area_index] = 1
        lis[loc_index] = 1
    
    return round(LinearModel.predict([lis])[0], 2)

X.columns

predict_price('Carpet  Area', 'Whitefield', 1250, 2, 2, 3,1,152)

predict_price('Carpet  Area', 'Whitefield', 1850, 3, 1, 2,0,78)

import pickle
with open('bangalore_home_prices_model.pickle', 'wb') as obj:
    pickle.dump(LinearModel, obj)

import json
columns = {
    'Columns': [col.lower() for col in X.columns]
}
with open("Columns.json", 'w') as f:
    f.write(json.dumps(columns))